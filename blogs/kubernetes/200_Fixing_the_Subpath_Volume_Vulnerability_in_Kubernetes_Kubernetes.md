|             Article Data             ||
| ----------------- | ----------------- |
| URL               | https://kubernetes.io/blog/2018/04/04/fixing-subpath-volume-vulnerability/        |
| Tags              | [kubernetes]       |
| Date Create       | 2018-04-04 00:00:00 &#43;0000 UTC |
| Date Parse        | 2021-12-06 10:51:20.9065531 &#43;0300 MSK m=&#43;2.495589901  |

# Fixing the Subpath Volume Vulnerability in Kubernetes | Kubernetes

	
	
	
	
	On March 12, 2018, the Kubernetes Product Security team disclosed [CVE-2017-1002101](https://issue.k8s.io/60813), which allowed containers using [subpath](/docs/concepts/storage/volumes/#using-subpath) volume mounts to access files outside of the volume. This means that a container could access any file available on the host, including volumes for other containers that it should not have access to.
The vulnerability has been fixed and released in the latest Kubernetes patch releases. We recommend that all users upgrade to get the fix. For more details on the impact and how to get the fix, please see the [announcement](https://groups.google.com/forum/#!topic/kubernetes-announce/6sNHO_jyBzE). (Note, some functional regressions were found after the initial fix and are being tracked in [issue #61563](https://github.com/kubernetes/kubernetes/issues/61563)).
This post presents a technical deep dive on the vulnerability and the solution.
To understand the vulnerability, one must first understand how volume and subpath mounting works in Kubernetes.
Before a container is started on a node, the kubelet volume manager locally mounts all the volumes specified in the PodSpec under a directory for that Pod on the host system. Once all the volumes are successfully mounted, it constructs the list of volume mounts to pass to the container runtime. Each volume mount contains information that the container runtime needs, the most relevant being:
When starting the container, the container runtime creates the path in the container root filesystem, if necessary, and then bind mounts it to the provided host path.
Subpath mounts are passed to the container runtime just like any other volume. The container runtime does not distinguish between a base volume and a subpath volume, and handles them the same way. Instead of passing the host path to the root of the volume, Kubernetes constructs the host path by appending the Pod-specified subpath (a relative path) to the base volume’s host path.
For example, here is a spec for a subpath volume mount:
```apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-container
    &lt;snip&gt;
    volumeMounts:
    - mountPath: /mnt/data
      name: my-volume
      subPath: dataset1
  volumes:
  - name: my-volume
    emptyDir: {}
```In this example, when the Pod gets scheduled to a node, the system will:
The vulnerability with subpath volumes was discovered by Maxim Ivanov, by making a few observations:
The basic example below demonstrates the vulnerability. It takes advantage of the observations outlined above by:
```apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  initContainers:
  - name: prep-symlink
    image: &#34;busybox&#34;
    command: [&#34;bin/sh&#34;, &#34;-ec&#34;, &#34;ln -s / /mnt/data/symlink-door&#34;]
    volumeMounts:
    - name: my-volume
      mountPath: /mnt/data
  containers:
  - name: my-container
    image: &#34;busybox&#34;
    command: [&#34;/bin/sh&#34;, &#34;-ec&#34;, &#34;ls /mnt/data; sleep 999999&#34;]
    volumeMounts:
    - mountPath: /mnt/data
      name: my-volume
      subPath: symlink-door
  volumes:
  - name: my-volume
    emptyDir: {}
```For this example, the system will:
This is a manifestation of a [symlink race](https://en.wikipedia.org/wiki/Symlink_race), where a malicious user program can gain access to sensitive data by causing a privileged program (in this case, kubelet) to follow a user-created symlink.
It should be noted that init containers are not always required for this exploit, depending on the volume type. It is used in the EmptyDir example because EmptyDir volumes cannot be shared with other Pods, and only created when a Pod is created, and destroyed when the Pod is destroyed. For persistent volume types, this exploit can also be done across two different Pods sharing the same volume.
The underlying issue is that the host path for subpaths are untrusted and can point anywhere in the system. The fix needs to ensure that this host path is both:
The Kubernetes product security team went through many iterations of possible solutions before finally agreeing on a design.
Our first design was relatively simple. For each subpath mount in each container:
However, this design is prone to the classic time-of-check-to-time-of-use ([TOCTTOU](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)) problem. In between steps 2) and 3), the user could change the path back to a symlink. The proper solution needs some way to “lock” the path so that it cannot be changed in between validation and bind mounting by the container runtime. All the subsequent ideas use an intermediate bind mount by kubelet to achieve this “lock” step before handing it off to the container runtime. Once a bind mount is performed, the mount source is fixed and cannot be changed.
We went a bit wild with this idea:
While this design does ensure that the symlinks cannot point outside of the volume, it was ultimately rejected due to difficulties of implementing the chroot mechanism in 4) across all the various distros and environments that Kubernetes has to support, including containerized kubelets.
Coming back to earth a little bit, our next idea was to:
In theory, this sounded pretty simple, but in reality, 2) was quite difficult to implement correctly. Many scenarios had to be handled where volumes (like EmptyDir) could be on a shared filesystem, on a separate filesystem, on the root filesystem, or not on the root filesystem. NFS volumes ended up handling all bind mounts as a separate mount, instead of as a child to the base volume. There was additional uncertainty about how out-of-tree volume types (that we couldn’t test) would behave.
Given the amount of scenarios and corner cases that had to be handled with the previous design, we really wanted to find a solution that was more generic across all volume types. The final design that we ultimately went with was to:
Note that this solution is different for Windows hosts, where the mounting semantics are different than Linux. In Windows, the design is to:
Both solutions are able to address all the requirements of:
Special thanks to many folks involved with handling this vulnerability:
If you find a vulnerability in Kubernetes, please follow our responsible disclosure process and [let us know](https://kubernetes.io/security/#report-a-vulnerability); we want to do our best to make Kubernetes secure for all users.
-- Michelle Au, Software Engineer, Google; and Jan Šafránek, Software Engineer, Red Hat


	

	


